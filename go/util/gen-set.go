// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package util

import "sync"

// https://flaviocopes.com/golang-data-structure-set/

//go:generate go run github.com/cheekybits/genny -in=$GOFILE -out=gen-$GOFILE gen "String=string,int,Coord"

// StringSet the set of Strings
type StringSet struct {
	items map[string]bool
	lock  sync.RWMutex
}

func (s *StringSet) Add(t string) *StringSet {
	s.lock.Lock()
	defer s.lock.Unlock()
	if s.items == nil {
		s.items = make(map[string]bool)
	}

	_, ok := s.items[t]
	if !ok {
		s.items[t] = true
	}
	return s
}

func (s *StringSet) Clear() {
	s.lock.Lock()
	defer s.lock.Unlock()
	s.items = make(map[string]bool)
}

func (s *StringSet) Delete(item string) bool {
	s.lock.Lock()
	defer s.lock.Unlock()
	_, ok := s.items[item]
	if ok {
		delete(s.items, item)
	}
	return ok
}

func (s *StringSet) Has(item string) bool {
	s.lock.RLock()
	defer s.lock.RUnlock()
	_, ok := s.items[item]
	return ok
}

func (s *StringSet) Strings() []string {
	s.lock.RLock()
	defer s.lock.RUnlock()
	items := []string{}
	for i := range s.items {
		items = append(items, i)
	}
	return items
}

func (s *StringSet) Size() int {
	s.lock.RLock()
	defer s.lock.RUnlock()
	return len(s.items)
}

// Union returns a new set with elements from both
// the given sets
func (s *StringSet) Union(s2 *StringSet) *StringSet {
	s3 := StringSet{}
	s3.items = make(map[string]bool)
	s.lock.RLock()
	for i := range s.items {
		s3.items[i] = true
	}
	s.lock.RUnlock()
	s2.lock.RLock()
	for i := range s2.items {
		_, ok := s3.items[i]
		if !ok {
			s3.items[i] = true
		}
	}
	s2.lock.RUnlock()
	return &s3
}

// Intersection returns a new set with elements that exist in
// both sets
func (s *StringSet) Intersection(s2 *StringSet) *StringSet {
	s3 := StringSet{}
	s3.items = make(map[string]bool)
	s.lock.RLock()
	s2.lock.RLock()
	defer s.lock.RUnlock()
	defer s2.lock.RUnlock()
	for i := range s2.items {
		_, ok := s.items[i]
		if ok {
			s3.items[i] = true
		}
	}
	return &s3
}

// Difference returns a new set with all the elements that
// exist in the first set and don't exist in the second set
func (s *StringSet) Difference(s2 *StringSet) *StringSet {
	s3 := StringSet{}
	s3.items = make(map[string]bool)
	s.lock.RLock()
	s2.lock.RLock()
	defer s.lock.RUnlock()
	defer s2.lock.RUnlock()
	for i := range s.items {
		_, ok := s2.items[i]
		if !ok {
			s3.items[i] = true
		}
	}
	return &s3
}

// Subset returns true if s is a subset of s2
func (s *StringSet) Subset(s2 *StringSet) bool {
	s.lock.RLock()
	s2.lock.RLock()
	defer s.lock.RUnlock()
	defer s2.lock.RUnlock()
	for i := range s.items {
		_, ok := s2.items[i]
		if !ok {
			return false
		}
	}
	return true
}

// https://flaviocopes.com/golang-data-structure-set/

//go:generate go run github.com/cheekybits/genny -in=$GOFILE -out=gen-$GOFILE gen "Int=string,int,Coord"

// IntSet the set of Ints
type IntSet struct {
	items map[int]bool
	lock  sync.RWMutex
}

func (s *IntSet) Add(t int) *IntSet {
	s.lock.Lock()
	defer s.lock.Unlock()
	if s.items == nil {
		s.items = make(map[int]bool)
	}

	_, ok := s.items[t]
	if !ok {
		s.items[t] = true
	}
	return s
}

func (s *IntSet) Clear() {
	s.lock.Lock()
	defer s.lock.Unlock()
	s.items = make(map[int]bool)
}

func (s *IntSet) Delete(item int) bool {
	s.lock.Lock()
	defer s.lock.Unlock()
	_, ok := s.items[item]
	if ok {
		delete(s.items, item)
	}
	return ok
}

func (s *IntSet) Has(item int) bool {
	s.lock.RLock()
	defer s.lock.RUnlock()
	_, ok := s.items[item]
	return ok
}

func (s *IntSet) Ints() []int {
	s.lock.RLock()
	defer s.lock.RUnlock()
	items := []int{}
	for i := range s.items {
		items = append(items, i)
	}
	return items
}

func (s *IntSet) Size() int {
	s.lock.RLock()
	defer s.lock.RUnlock()
	return len(s.items)
}

// Union returns a new set with elements from both
// the given sets
func (s *IntSet) Union(s2 *IntSet) *IntSet {
	s3 := IntSet{}
	s3.items = make(map[int]bool)
	s.lock.RLock()
	for i := range s.items {
		s3.items[i] = true
	}
	s.lock.RUnlock()
	s2.lock.RLock()
	for i := range s2.items {
		_, ok := s3.items[i]
		if !ok {
			s3.items[i] = true
		}
	}
	s2.lock.RUnlock()
	return &s3
}

// Intersection returns a new set with elements that exist in
// both sets
func (s *IntSet) Intersection(s2 *IntSet) *IntSet {
	s3 := IntSet{}
	s3.items = make(map[int]bool)
	s.lock.RLock()
	s2.lock.RLock()
	defer s.lock.RUnlock()
	defer s2.lock.RUnlock()
	for i := range s2.items {
		_, ok := s.items[i]
		if ok {
			s3.items[i] = true
		}
	}
	return &s3
}

// Difference returns a new set with all the elements that
// exist in the first set and don't exist in the second set
func (s *IntSet) Difference(s2 *IntSet) *IntSet {
	s3 := IntSet{}
	s3.items = make(map[int]bool)
	s.lock.RLock()
	s2.lock.RLock()
	defer s.lock.RUnlock()
	defer s2.lock.RUnlock()
	for i := range s.items {
		_, ok := s2.items[i]
		if !ok {
			s3.items[i] = true
		}
	}
	return &s3
}

// Subset returns true if s is a subset of s2
func (s *IntSet) Subset(s2 *IntSet) bool {
	s.lock.RLock()
	s2.lock.RLock()
	defer s.lock.RUnlock()
	defer s2.lock.RUnlock()
	for i := range s.items {
		_, ok := s2.items[i]
		if !ok {
			return false
		}
	}
	return true
}

// https://flaviocopes.com/golang-data-structure-set/

//go:generate go run github.com/cheekybits/genny -in=$GOFILE -out=gen-$GOFILE gen "Coord=string,int,Coord"

// CoordSet the set of Coords
type CoordSet struct {
	items map[Coord]bool
	lock  sync.RWMutex
}

func (s *CoordSet) Add(t Coord) *CoordSet {
	s.lock.Lock()
	defer s.lock.Unlock()
	if s.items == nil {
		s.items = make(map[Coord]bool)
	}

	_, ok := s.items[t]
	if !ok {
		s.items[t] = true
	}
	return s
}

func (s *CoordSet) Clear() {
	s.lock.Lock()
	defer s.lock.Unlock()
	s.items = make(map[Coord]bool)
}

func (s *CoordSet) Delete(item Coord) bool {
	s.lock.Lock()
	defer s.lock.Unlock()
	_, ok := s.items[item]
	if ok {
		delete(s.items, item)
	}
	return ok
}

func (s *CoordSet) Has(item Coord) bool {
	s.lock.RLock()
	defer s.lock.RUnlock()
	_, ok := s.items[item]
	return ok
}

func (s *CoordSet) Coords() []Coord {
	s.lock.RLock()
	defer s.lock.RUnlock()
	items := []Coord{}
	for i := range s.items {
		items = append(items, i)
	}
	return items
}

func (s *CoordSet) Size() int {
	s.lock.RLock()
	defer s.lock.RUnlock()
	return len(s.items)
}

// Union returns a new set with elements from both
// the given sets
func (s *CoordSet) Union(s2 *CoordSet) *CoordSet {
	s3 := CoordSet{}
	s3.items = make(map[Coord]bool)
	s.lock.RLock()
	for i := range s.items {
		s3.items[i] = true
	}
	s.lock.RUnlock()
	s2.lock.RLock()
	for i := range s2.items {
		_, ok := s3.items[i]
		if !ok {
			s3.items[i] = true
		}
	}
	s2.lock.RUnlock()
	return &s3
}

// Intersection returns a new set with elements that exist in
// both sets
func (s *CoordSet) Intersection(s2 *CoordSet) *CoordSet {
	s3 := CoordSet{}
	s3.items = make(map[Coord]bool)
	s.lock.RLock()
	s2.lock.RLock()
	defer s.lock.RUnlock()
	defer s2.lock.RUnlock()
	for i := range s2.items {
		_, ok := s.items[i]
		if ok {
			s3.items[i] = true
		}
	}
	return &s3
}

// Difference returns a new set with all the elements that
// exist in the first set and don't exist in the second set
func (s *CoordSet) Difference(s2 *CoordSet) *CoordSet {
	s3 := CoordSet{}
	s3.items = make(map[Coord]bool)
	s.lock.RLock()
	s2.lock.RLock()
	defer s.lock.RUnlock()
	defer s2.lock.RUnlock()
	for i := range s.items {
		_, ok := s2.items[i]
		if !ok {
			s3.items[i] = true
		}
	}
	return &s3
}

// Subset returns true if s is a subset of s2
func (s *CoordSet) Subset(s2 *CoordSet) bool {
	s.lock.RLock()
	s2.lock.RLock()
	defer s.lock.RUnlock()
	defer s2.lock.RUnlock()
	for i := range s.items {
		_, ok := s2.items[i]
		if !ok {
			return false
		}
	}
	return true
}
